0001   0000             ;
0002   0000             ; Original Code and hardware by Frank Palazzolo
0003   0000             ; Code written and working sometime in the early 2000's
0004   0000             ; Source Reverse-engineered from Binary(!)
0005   0000             ; And updated for standard SPI master interface - 2022-October
0006   0000             ; Added Chip ID functions, 2022-November
0007   0000             ;
0008   0000             ; This code can be built with TASM Version 3.2:
0009   0000             ;   tasm -70 -g3 -fff -s -c dumper.asm dumper.bin
0010   0000             ;
0011   0000             ; Dumper code for PIC70XX, TMS70XX, TMS70XXX, TMS77XX, TMS70CXX, and TMS77CXX chips
0012   0000             ;
0013   0000             ; Hardware connections:
0014   0000             ;
0015   0000             ; ~INT1 and ~INT3 wired to +5 - pins 13 and 12 on DIP
0016   0000             ; Port B, bit 0 - Pin 3 on DIP  - MC Pin is connected here, along with a 4.7k pullup 
0017   0000             ; Port B, bit 1 - Pin 4 on DIP  - MOSI - Bits appear here
0018   0000             ; Port B, bit 2 - Pin 5 on DIP  - SCLK - Rising Edge happens during bit
0019   0000             ; Port B, bit 3 - Pin 37 on DIP - ~SS
0020   0000             ;
0021   0000             ; When External Memory is enabled:
0022   0000             ;
0023   0000             ; Port B, bit 4 - Pin 38 on DIP - ALATCH
0024   0000             ; Port B, bit 5 - Pin 1 on DIP  - R/~W 
0025   0000             ; Port B, bit 6 - Pin 39 on DIP - ~ENABLE
0026   0000             ; Port B, bit 7 - Pin 2 on DIP  - CLKOUT 
0027   0000             ; Port C, all   - Address Low / Data Bus
0028   0000             ; Port D, all   - Address High Bus
0029   0000             
0030   0000             ; Chip starts up in Microprocessor mode, executing ROM from external memory
0031   0000             ; 1) Code checks ram size and for presence of serial port, to generate initial ID byte
0032   0000             ; 2) Trojan Code segment is copied from external ROM to internal RAM
0033   0000             ; 3) Jump to code in internal RAM 
0034   0000             ; 4) Switch modes, enabling internal ROM 
0035   0000             ; 5) Code determines internal ROM size and adjusts ID byte
0036   0000             ; 6) Code clocks out bytes via SPI:
0037   0000             ;    ID byte, followed by 0K, 2K, or 4K bytes
0038   0000             
0039   0000             ; RAM Layout
0040   0000             ; 0x00-0x07 - A,B,R2-R7 Used as general purpose storage
0041   0000             ; 0x08-0x7C - Used for Trojan program
0042   0000             ; 0x7D-0x7E - Spare
0043   0000             ; 0x7F      - used to determine RAM size
0044   0000             
0045   0000             ; ID Byte -
0046   0000             ;     0x00 - 0b00000000 - 128 bytes of ram, 0K ROM
0047   0000             ;     0x01 - 0b00000001 - 128 bytes of ram, serial port, 0K ROM
0048   0000             ;     0x02 - 0b00000010 - 256 bytes of ram, 0K ROM
0049   0000             ;     0x03 - 0b00000011 - 256 bytes of ram, serial port, 0K ROM
0050   0000             ;     0x04 - 0b00000100 - 128 bytes of ram, 2K ROM
0051   0000             ;     0x05 - 0b00000101 - 128 bytes of ram, serial port, 2K ROM
0052   0000             ;     0x06 - 0b00000110 - 256 bytes of ram, 0K ROM
0053   0000             ;     0x07 - 0b00000111 - 256 bytes of ram, serial port, 2K ROM
0054   0000             ;     0x08 - 0b00001000 - 128 bytes of ram, 4K ROM
0055   0000             ;     0x09 - 0b00001001 - 128 bytes of ram, serial port, 4K ROM
0056   0000             ;     0x0a - 0b00001010 - 256 bytes of ram, 4K ROM
0057   0000             ;     0x0b - 0b00001011 - 256 bytes of ram, serial port, 4K ROM
0058   0000             ;     0x10 - 0b00010000 - 128 bytes of ram, >4K ROM
0059   0000             ;     0x11 - 0b00010001 - 128 bytes of ram, serial port, >4K ROM
0060   0000             ;     0x12 - 0b00010010 - 256 bytes of ram, >4K ROM
0061   0000             ;     0x13 - 0b00010011 - 256 bytes of ram, serial port, >4K ROM
0062   0000             ;     Any other values are errors
0063   0000             
0064   0000             ;R0      .equ    0   ; AKA A Register
0065   0000             ;R1      .equ    1   ; AKA B Register
0066   0000             R2      .equ    2
0067   0000             R3      .equ    3
0068   0000             R4      .equ    4
0069   0000             R5      .equ    5
0070   0000             R6      .equ    6
0071   0000             R7      .equ    7
0072   0000             
0073   0000             ; peripherals
0074   0000             
0075   0000             IOCNT0  .equ    0   ; Used to control modes via the CPU
0076   0000             BPORT   .equ    6   ; Used to switch modes via external connection, and used for SPI interface 
0077   0000             SCTL1   .equ    21  ; Used to probe for a Serial Port on the 70x2
0078   0000             SCTL1C  .equ    24  ; Used to probe for a Serial Port on the 70Cx2
0079   0000             
0080   0000             RAMDEST .equ    $0008       ; location in ram for the code to be copied into and run from
0081   0000                                         ; Right now, this just barely fits into 128 bytes of RAM
0082   0000             
0083   E000                     .ORG    $E000       ; External Memory in the last 8K
0084   E000 E0 E0 E0 E0         .FILL   $20,$E0     ; If this data is read in Full Expansion mode, then this is not a >6K internal ROM chip
0084   E004 E0 E0 E0 E0 
0084   E008 E0 E0 E0 E0 
0084   E00C E0 E0 E0 E0 
0084   E010 E0 E0 E0 E0 
0084   E014 E0 E0 E0 E0 
0084   E018 E0 E0 E0 E0 
0084   E01C E0 E0 E0 E0 
0085   E020             
0086   E020                     ; Initialize port, stack
0087   E020             START:
0088   E020 A2 FF 06            MOVP    %$FF,BPORT  ; PORTB = FF, PORTB=All ones (MC high, make sure external ROM enabled)
0089   E023 52 0C               MOV     %$0C,B      ; B  = 0C
0090   E025 0D                  LDSP                ; SP = 000C - we don't use stack anyway
0091   E026 A2 AA 00            MOVP    %$AA,IOCNT0 ; Disable some interrupts, set for Full Expansion mode after mode switch
0092   E029             
0093   E029                     ; Try to identify this chip and store a code in R3
0094   E029             
0095   E029             RAMCHK:
0096   E029                     ; Identify RAM size:
0097   E029                     ; do checks twice with different data,
0098   E029                     ; to protect against random luck matches
0099   E029             
0100   E029 72 55 FF            MOV     %$55,$ff
0101   E02C 72 AA 7F            MOV     %$AA,$7f
0102   E02F 7D 55 FF            CMP     %$55,$ff    ; check for 256 bytes working
0103   E032 E6 10               JNZ     RAM128
0104   E034 72 AA FF            MOV     %$AA,$ff
0105   E037 72 55 7F            MOV     %$55,$7f
0106   E03A 7D AA FF            CMP     %$AA,$ff    ; doublecheck for 256 bytes working
0107   E03D E6 05               JNZ     RAM128
0108   E03F             
0109   E03F             RAM256:
0110   E03F 72 02 03            MOV     %$02,R3     ; 256 bytes
0111   E042 E0 05               JMP     SERCHK
0112   E044             RAM128:
0113   E044 72 00 03            MOV     %$00,R3     ; 128 bytes
0114   E047 E0 00               JMP     SERCHK
0115   E049             
0116   E049                     ; Try to store bottom two bits of SCTL1 register and see if they stay
0117   E049                     ; if so, we have a UART
0118   E049                     ; We try both the locations, once for the 70X2 chip, and then the 70CX2 chip
0119   E049             
0120   E049             SERCHK:
0121   E049 A3 FC 15            ANDP    %$FC,SCTL1  ; zero the 2 LS bits
0122   E04C 80 15               MOVP    SCTL1,A
0123   E04E 23 03               AND     %$03,A
0124   E050 E6 16               JNZ     SERCHKC     ; fail if not zero
0125   E052 A4 01 15            ORP     %$01,SCTL1  ; set the bottom bit
0126   E055 80 15               MOVP    SCTL1,A
0127   E057 23 03               AND     %$03,A 
0128   E059 2D 01               CMP     %$01,A      ; check if it's a one now
0129   E05B E6 0B               JNZ     SERCHKC     ; or fail
0130   E05D A4 02 15            ORP     %$02,SCTL1  ; set the next bit
0131   E060 80 15               MOVP    SCTL1,A
0132   E062 23 03               AND     %$03,A 
0133   E064 2D 03               CMP     %$03,A      ; should be 3 now
0134   E066 E2 1F               JZ      SERFOUND    ; if not fail
0135   E068             
0136   E068             SERCHKC:
0137   E068 A3 FC 18            ANDP    %$FC,SCTL1C  ; zero the 2 LS bits
0138   E06B 80 18               MOVP    SCTL1C,A
0139   E06D 23 03               AND     %$03,A
0140   E06F E6 19               JNZ     SERFAIL     ; fail if not zero
0141   E071 A4 01 18            ORP     %$01,SCTL1C  ; set the bottom bit
0142   E074 80 18               MOVP    SCTL1C,A
0143   E076 23 03               AND     %$03,A 
0144   E078 2D 01               CMP     %$01,A      ; check if it's a one now
0145   E07A E6 0E               JNZ     SERFAIL     ; or fail
0146   E07C A4 02 18            ORP     %$02,SCTL1C  ; set the next bit
0147   E07F 80 18               MOVP    SCTL1C,A
0148   E081 23 03               AND     %$03,A 
0149   E083 2D 03               CMP     %$03,A      ; should be 3 now
0150   E085 E6 03               JNZ     SERFAIL     ; if not fail
0151   E087             SERFOUND:
0152   E087 74 01 03            OR      %$01,R3     ; UART detected, set this bit
0153   E08A             SERFAIL:
0154   E08A             
0155   E08A                     ; Copy code from External ROM to RAM
0156   E08A             
0157   E08A             COPYCODE:
0158   E08A 88 E0 AD 05         MOVD    %RAMCODE,R5 ; Start of ROM source
0159   E08E 88 00 08 07         MOVD    %RAMDEST,R7 ; Start of RAM destination
0160   E092             CPYLOOP:
0161   E092 9A 05               LDA     *R5         ; grab code byte
0162   E094 9B 07               STA     *R7         ; move code byte
0163   E096 D3 07               INC     R7          ; increment destination
0164   E098 79 00 06            ADC     %$0,R6      ; ripple carry to high byte
0165   E09B D3 05               INC     R5          ; increment source
0166   E09D 79 00 04            ADC     %$0,R4      ; ripple carry to high byte
0167   E0A0 7D E0 04            CMP     %(ENDCODE/$100),R4          ; am I at high byte of ENDCODE?
0168   E0A3 E6 ED               JNZ     CPYLOOP     ; if we are not done, loop to copy next byte
0169   E0A5 7D B8 05            CMP     %$(ENDCODE%$100),R5         ; am I at low byte of ENDCODE?
0170   E0A8 E6 E8               JNZ     CPYLOOP     ; if we are not done, loop to copy next byte
0171   E0AA             
0172   E0AA                     ; We reached ENDCODE, so our code copy to RAM is done
0173   E0AA 8C 00 08            BR      @RAMDEST    ; jump to code in RAM
0174   E0AD             
0175   E0AD             ; Start of code to be executed in RAM
0176   E0AD             ; (Must be relocatable)
0177   E0AD             
0178   E0AD             RAMCODE:
0179   E0AD A2 FE 06            MOVP    %$FE,BPORT  ; PORTB = FE, PORTB.0=0 (Flip the MC pin low, internal ROM enabled)
0180   E0B0 52 FF               MOV     %$FF,B      ; B = FF
0181   E0B2             DELAY:
0182   E0B2 C2                  DEC     B           ; B = B-1
0183   E0B3 E6 FD               JNZ     DELAY       ; wait a bit for things to settle
0184   E0B5 8C E0 B8            BR      @BACK2ROM
0185   E0B8             
0186   E0B8             ENDCODE:
0187   E0B8             ;       End of code to be executed in RAM
0188   E0B8             
0189   E0B8             ;   determine internal ROM size
0190   E0B8             
0191   E0B8             BACK2ROM:
0192   E0B8 88 E8 00 05         MOVD    %$E800,R5   ; Start of 6K ROM
0193   E0BC 9A 05       X1:     LDA     *R5
0194   E0BE 1D 04               CMP     R4,A        ; expected byte in R4 if reading external memory
0195   E0C0 E6 11               JNZ     NOMATCH
0196   E0C2 D3 05               INC     R5
0197   E0C4 7D 20 05            CMP     %$20,R5     ; done checking 32 bytes?
0198   E0C7 E6 F3               JNZ     X1
0199   E0C9 72 00 05            MOV     %$0,R5      ; if so, start next region, + 0x0800
0200   E0CC 78 08 04            ADD     %$8,R4
0201   E0CF E6 EB               JNZ     X1          ; done with all regions?
0202   E0D1             
0203   E0D1             ROM0K:
0204   E0D1 E0 1A               JMP     FINISHUP
0205   E0D3             
0206   E0D3             NOMATCH:
0207   E0D3 7D E8 04            CMP     %$E8,R4     ; >4K ROM check if match
0208   E0D6 E6 08               JNZ     NEXTCHK
0209   E0D8             
0210   E0D8             ROM12K:
0211   E0D8 74 10 03            OR      %$10,R3
0212   E0DB 72 CF 04            MOV     %$CF,R4     ; R4:R5 = D000-1, (Start of 12K Internal ROM)
0213   E0DE E0 0F               JMP     DODUMP
0214   E0E0             
0215   E0E0             NEXTCHK:
0216   E0E0 7D F0 04            CMP     %$F0,R4     ; 4K ROM if match
0217   E0E3 E6 05               JNZ     ROM2K
0218   E0E5             
0219   E0E5 74 08 03    ROM4K:  OR      %$08,R3
0220   E0E8 E0 03               JMP     FINISHUP
0221   E0EA                                         
0222   E0EA             ROM2K:  
0223   E0EA 74 04 03            OR      %$04,R3
0224   E0ED             FINISHUP:
0225   E0ED D2 04               DEC     R4          ;    R4:R5 = 0000-1, (End of Internal ROM)
0226   E0EF                                         ; or R4:R5 = F000-1, (Start of 4K Internal ROM)
0227   E0EF                                         ; or R4:R5 = F800-1, (Start of 2K Internal ROM)
0228   E0EF                     
0229   E0EF             DODUMP:
0230   E0EF 72 FF 05            MOV     %$FF,R5
0231   E0F2             
0232   E0F2 A3 FB 06            ANDP    %$FB,BPORT  ; PORTB.2 = SCK = 0
0233   E0F5 A3 F7 06            ANDP    %$F7,BPORT  ; PORTB.3 = ~SS = 0
0234   E0F8 12 03               MOV     R3,A
0235   E0FA E0 02               JMP     JUMPIN
0236   E0FC             
0237   E0FC             NXTBYTE:
0238   E0FC 9A 05               LDA     *R5         ; Read internal ROM byte
0239   E0FE             JUMPIN:
0240   E0FE 72 08 02            MOV     %$8,R2      ; R2 = 8, bit counter?
0241   E101             NXTBIT:
0242   E101 A3 FB 06            ANDP    %$FB,BPORT  ; PORTB.2 = SCK = 0
0243   E104             
0244   E104 BE                  RL      A           ; get each bit, MSB first
0245   E105 E3 05               JHS     DOONE       ; if 1, jump
0246   E107 A3 FD 06            ANDP    %$FD,BPORT  ; PORTB.1 = MOSI = 0
0247   E10A E0 03               JMP     AHEAD
0248   E10C             DOONE:
0249   E10C A4 02 06            ORP     %$02,BPORT  ; PORTB.1 = MOSI = 1
0250   E10F             AHEAD:
0251   E10F A4 04 06            ORP     %$04,BPORT  ; PORTB.2 = SCK = 1
0252   E112 D2 02               DEC     R2          ; decrement bit counter
0253   E114 E6 EB               JNZ     NXTBIT      ; do next bit
0254   E116             
0255   E116 D3 05               INC     R5          ; increment for next location to read
0256   E118 79 00 04            ADC     %$0,R4
0257   E11B E6 DF               JNZ     NXTBYTE     ; unless we roll over to 0000, do next byte
0258   E11D             
0259   E11D A3 FB 06            ANDP    %$FB,BPORT  ; PORTB.2 = SCK = 0
0260   E120 A4 08 06            ORP     %$08,BPORT  ; PORTB.3 = ~SS = 1
0261   E123             
0262   E123             DONE:
0263   E123 E0 FE               JMP     DONE        ; loop forever
0264   E125             ;ENDCODE:
0265   E125             ;       End of code to be executed in RAM
0266   E125             
0267   E125             RPRGSIZE .equ   ENDCODE-RAMCODE
0268   E125             
0269   E800                     .ORG    $E800       ; External Memory in the last 6K
0270   E800 E8 E8 E8 E8         .FILL   $20,$E8     ; If this data is read in Full Expansion mode, then this is not a >4K internal ROM chip
0270   E804 E8 E8 E8 E8 
0270   E808 E8 E8 E8 E8 
0270   E80C E8 E8 E8 E8 
0270   E810 E8 E8 E8 E8 
0270   E814 E8 E8 E8 E8 
0270   E818 E8 E8 E8 E8 
0270   E81C E8 E8 E8 E8 
0271   E820             
0272   F000                     .ORG    $F000       ; External Memory in the last 4K
0273   F000 F0 F0 F0 F0         .FILL   $20,$F0     ; If this data is read in Full Expansion mode, then this is not a 4K internal ROM chip
0273   F004 F0 F0 F0 F0 
0273   F008 F0 F0 F0 F0 
0273   F00C F0 F0 F0 F0 
0273   F010 F0 F0 F0 F0 
0273   F014 F0 F0 F0 F0 
0273   F018 F0 F0 F0 F0 
0273   F01C F0 F0 F0 F0 
0274   F020             
0275   F800                     .ORG    $F800       ; External Memory in the last 2K
0276   F800 F8 F8 F8 F8         .FILL   $20,$F8     ; If this code is read in Full Expansion mode, then this is not a 2K internal ROM chip
0276   F804 F8 F8 F8 F8 
0276   F808 F8 F8 F8 F8 
0276   F80C F8 F8 F8 F8 
0276   F810 F8 F8 F8 F8 
0276   F814 F8 F8 F8 F8 
0276   F818 F8 F8 F8 F8 
0276   F81C F8 F8 F8 F8 
0277   F820             
0278   F820                     ; Vectors go here
0279   F820             
0280   FFF8                     .ORG    0FFF8H
0281   FFF8             
0282   FFF8                     .MSFIRST            ; need this, or .word statements are backwards for this CPU
0283   FFF8             
0284   FFF8 E0 20               .word   START
0285   FFFA E0 20               .word   START
0286   FFFC E0 20               .word   START
0287   FFFE E0 20               .word   START
0288   10000             
0289   10000                     .end
0290   10000             
0291   10000             
tasm: Number of errors = 0
