0001   0000             ;
0002   0000             ; Original Code and hardware by Frank Palazzolo
0003   0000             ; Code written and working sometime in the early 2000's
0004   0000             ; Source Reverse-engineered from Binary(!)
0005   0000             ; And updated for standard SPI master interface - 2022-October
0006   0000             ; Added Chip ID functions, 2022-November
0007   0000             ; Switched to Memory-Mapped I/O, added support for CT and Piggyback chips - 2022-December
0008   0000             ;
0009   0000             ; This code can be built with TASM Version 3.2:
0010   0000             ;   tasm -70 -g3 -fff -s -c dumper.asm dumper.bin
0011   0000             ; Then, to make the rom image, use:
0012   0000             ;   python makerom.py
0013   0000             ;
0014   0000             ; Dumper code for all TMS7000 series parts
0015   0000             ;
0016   0000             ; Hardware connections:
0017   0000             ;
0018   0000             ; ~INT1 and ~INT3 wired to +5 - pins 13 and 12 on DIP
0019   0000             ; Arduino can be written to by writing to any external memory address (code uses 0x1000)
0020   0000             ; MC set to Vcc on startup by Arduino
0021   0000             ; First write of 0x55 signals Arduino to flip MC from high to low
0022   0000             ; Second write to Arduino is the ChipID byte
0023   0000             ; Subsequent writes are dumps of Internal ROM
0024   0000             ;   (length is dependant on the ChipID byte)
0025   0000             ;
0026   0000             ; When External Memory is enabled:
0027   0000             ;
0028   0000             ; Port B, bit 4 - Pin 38 on DIP - ALATCH
0029   0000             ; Port B, bit 5 - Pin 1 on DIP  - R/~W 
0030   0000             ; Port B, bit 6 - Pin 39 on DIP - ~ENABLE
0031   0000             ; Port B, bit 7 - Pin 2 on DIP  - CLKOUT 
0032   0000             ; Port C, all   - Address Low / Data Bus
0033   0000             ; Port D, all*  - Address High Bus
0034   0000             ; NOTE: Since the CT chips only have the upper 4 bits of Port D,
0035   0000             ; We have mapped external memory such that every 4K block of TMS7000 space
0036   0000             ; contains 16 copies of a single 256 byte block of the ROM chip
0037   0000             ;
0038   0000             ; Chip starts up in Microprocessor mode, executing ROM from external memory
0039   0000             ; 1) Boots to 0x1000 - Code checks ram size and for presence of serial port, to generate initial ID byte
0040   0000             ; 2) Trojan Code segment is copied from external ROM to internal RAM
0041   0000             ; 3) Jump to code in internal RAM 
0042   0000             ; 4) RAM-resident code sends Arduino a 0x55 to switch modes, enabling internal ROM
0043   0000             ; 5) Jump back to external ROM
0044   0000             ; 6) Code determines internal ROM size and adjusts ID byte
0045   0000             ; 7) Code writes out bytes to Arduino:
0046   0000             ;    ID byte, followed by internal ROM bytes
0047   0000             
0048   0000             ; RAM Layout
0049   0000             ; 0x00-0x07 - A,B,R2-R7 Used as general purpose storage
0050   0000             ; 0x08-0x18 - Reserved for Trojan program
0051   0000             ; 0x19-0x7E - Spare
0052   0000             ; 0x7F      - used to determine RAM size
0053   0000             
0054   0000             ; ID Byte bit definition:
0055   0000             ;
0056   0000             ; bit 0:    0 = No Serial Port, 1 = Serial Port detected
0057   0000             ; bit 1:    0 = 128 bytes of RAM, 1 = 256 bytes of RAM
0058   0000             ; bits 2-5: number of 2K blocks of Internal ROM present (0-8) = (0K-16K)
0059   0000             ; bits 6-7: unused
0060   0000             
0061   0000             ;R0      .equ    0   ; AKA A Register
0062   0000             ;R1      .equ    1   ; AKA B Register
0063   0000             
0064   0000             R2      .equ    2   ; Used as a Counter variable
0065   0000             R3      .equ    3   ; Used for ID byte
0066   0000             R4      .equ    4   ; R4:R5 used as primary 2-byte Memory Index
0067   0000             R5      .equ    5
0068   0000             R6      .equ    6   ; R6:R7 used as secondary 2-byte Memory Index
0069   0000             R7      .equ    7
0070   0000             
0071   0000             ; peripherals
0072   0000             
0073   0000             IOCNT0  .equ    0       ; Peripheral address to control CPU modes
0074   0000             ARDADDR .equ    $1000   ; Address to write a byte to the Arduino
0075   0000             SCTL1   .equ    21      ; Peripheral address to probe for a Serial Port on the 70x2
0076   0000             SCTL1C  .equ    24      ; Peripheral address to probe for a Serial Port on the 70Cx2
0077   0000             
0078   0000             RAMDEST .equ    $0008       ; location in ram for the code to be copied into and run from
0079   0000             
0080   0000             ; Binary image Layout:
0081   0000             ; We fill 64K of space with this program, but we only use 4K of it in the ROM
0082   0000             ; Each 4K block contains only 256 bytes of info
0083   0000             
0084   0000             ; 0x0X00 is unused.  The first 256 bytes will appear in the ROM
0085   0000             
0086   0000                     .ORG    $0000       ; nothing here, fill with zeros
0087   0000 00 00 00 00         .FILL   $100,$00
0087   0004 00 00 00 00 
0087   0008 00 00 00 00 
0087   000C 00 00 00 00 
0087   0010 00 00 00 00 
0087   0014 00 00 00 00 
0087   0018 00 00 00 00 
0087   001C 00 00 00 00 
0087   0020 00 00 00 00 
0087   0024 00 00 00 00 
0087   0028 00 00 00 00 
0087   002C 00 00 00 00 
0087   0030 00 00 00 00 
0087   0034 00 00 00 00 
0087   0038 00 00 00 00 
0087   003C 00 00 00 00 
0087   0040 00 00 00 00 
0087   0044 00 00 00 00 
0087   0048 00 00 00 00 
0087   004C 00 00 00 00 
0087   0050 00 00 00 00 
0087   0054 00 00 00 00 
0087   0058 00 00 00 00 
0087   005C 00 00 00 00 
0087   0060 00 00 00 00 
0087   0064 00 00 00 00 
0087   0068 00 00 00 00 
0087   006C 00 00 00 00 
0087   0070 00 00 00 00 
0087   0074 00 00 00 00 
0087   0078 00 00 00 00 
0087   007C 00 00 00 00 
0087   0080 00 00 00 00 
0087   0084 00 00 00 00 
0087   0088 00 00 00 00 
0087   008C 00 00 00 00 
0087   0090 00 00 00 00 
0087   0094 00 00 00 00 
0087   0098 00 00 00 00 
0087   009C 00 00 00 00 
0087   00A0 00 00 00 00 
0087   00A4 00 00 00 00 
0087   00A8 00 00 00 00 
0087   00AC 00 00 00 00 
0087   00B0 00 00 00 00 
0087   00B4 00 00 00 00 
0087   00B8 00 00 00 00 
0087   00BC 00 00 00 00 
0087   00C0 00 00 00 00 
0087   00C4 00 00 00 00 
0087   00C8 00 00 00 00 
0087   00CC 00 00 00 00 
0087   00D0 00 00 00 00 
0087   00D4 00 00 00 00 
0087   00D8 00 00 00 00 
0087   00DC 00 00 00 00 
0087   00E0 00 00 00 00 
0087   00E4 00 00 00 00 
0087   00E8 00 00 00 00 
0087   00EC 00 00 00 00 
0087   00F0 00 00 00 00 
0087   00F4 00 00 00 00 
0087   00F8 00 00 00 00 
0087   00FC 00 00 00 00 
0088   0100             
0089   0100             ; 0x1X00 contains the code block.  Only 256 bytes are available.
0090   0100             
0091   1000                     .ORG    $1000
0092   1000             
0093   1000                     ; Initialize port, stack
0094   1000             START:
0095   1000 52 0C               MOV     %$0C,B      ; B  = 0C
0096   1002 0D                  LDSP                ; SP = 000C - we don't use stack anyway
0097   1003 A2 AA 00            MOVP    %$AA,IOCNT0 ; Disable some interrupts, set for Full Expansion mode after mode switch
0098   1006             
0099   1006                     ; Try to identify this chip and store a code in R3
0100   1006 72 00 03            MOV     %$00,R3     ; Initialize ID byte to 0, (128 bytes of RAM)
0101   1009             
0102   1009             RAMCHK:
0103   1009                     ; Identify RAM size:
0104   1009                     ; do checks twice with different data,
0105   1009                     ; to protect against random luck matches
0106   1009             
0107   1009 72 55 FF            MOV     %$55,$ff
0108   100C 72 AA 7F            MOV     %$AA,$7f
0109   100F 7D 55 FF            CMP     %$55,$ff    ; check for 256 bytes working
0110   1012 E6 0E               JNZ     SERCHK      ; if fail, 128 bytes - jump to next step
0111   1014 72 AA FF            MOV     %$AA,$ff
0112   1017 72 55 7F            MOV     %$55,$7f
0113   101A 7D AA FF            CMP     %$AA,$ff    ; doublecheck for 256 bytes working
0114   101D E6 03               JNZ     SERCHK      ; if fail, 128 bytes - jump to next step
0115   101F             
0116   101F             RAM256:
0117   101F 72 02 03            MOV     %$02,R3     ; We have 256 bytes or RAM
0118   1022             
0119   1022                     ; Try to store bottom two bits of SCTL1 register and see if they "stay"
0120   1022                     ; if so, we have a UART
0121   1022                     ; We try both the locations, once for the 70X2 chip, and then the 70CX2 chip
0122   1022             
0123   1022             SERCHK:
0124   1022 A3 FC 15            ANDP    %$FC,SCTL1  ; zero the 2 LS bits
0125   1025 80 15               MOVP    SCTL1,A
0126   1027 23 03               AND     %$03,A
0127   1029 E6 16               JNZ     SERCHKC     ; fail if not zero
0128   102B A4 01 15            ORP     %$01,SCTL1  ; set the bottom bit
0129   102E 80 15               MOVP    SCTL1,A
0130   1030 23 03               AND     %$03,A 
0131   1032 2D 01               CMP     %$01,A      ; check if it's a one now
0132   1034 E6 0B               JNZ     SERCHKC     ; or fail
0133   1036 A4 02 15            ORP     %$02,SCTL1  ; set the next bit
0134   1039 80 15               MOVP    SCTL1,A
0135   103B 23 03               AND     %$03,A 
0136   103D 2D 03               CMP     %$03,A      ; should be 3 now
0137   103F E2 1F               JZ      SERFOUND    ; if not fail
0138   1041             
0139   1041             SERCHKC:
0140   1041 A3 FC 18            ANDP    %$FC,SCTL1C  ; zero the 2 LS bits
0141   1044 80 18               MOVP    SCTL1C,A
0142   1046 23 03               AND     %$03,A
0143   1048 E6 19               JNZ     COPYCODE     ; fail if not zero
0144   104A A4 01 18            ORP     %$01,SCTL1C  ; set the bottom bit
0145   104D 80 18               MOVP    SCTL1C,A
0146   104F 23 03               AND     %$03,A 
0147   1051 2D 01               CMP     %$01,A       ; check if it's a one now
0148   1053 E6 0E               JNZ     COPYCODE     ; or fail
0149   1055 A4 02 18            ORP     %$02,SCTL1C  ; set the next bit
0150   1058 80 18               MOVP    SCTL1C,A
0151   105A 23 03               AND     %$03,A 
0152   105C 2D 03               CMP     %$03,A       ; should be 3 now
0153   105E E6 03               JNZ     COPYCODE     ; if not fail
0154   1060             SERFOUND:
0155   1060 74 01 03            OR      %$01,R3     ; UART detected, set this bit
0156   1063             
0157   1063                     ; Copy code from External ROM to RAM
0158   1063             
0159   1063             COPYCODE:
0160   1063 72 10 02            MOV     %$10,R2     ; Byte Counter - our code is < 16 bytes
0161   1066 88 10 83 05         MOVD    %RAMCODE,R5 ; Start of ROM source
0162   106A 88 00 08 07         MOVD    %RAMDEST,R7 ; Start of RAM destination
0163   106E             CPYLOOP:
0164   106E 9A 05               LDA     *R5         ; grab code byte
0165   1070 9B 07               STA     *R7         ; move code byte
0166   1072 D3 07               INC     R7          ; increment destination
0167   1074 79 00 06            ADC     %$0,R6      ; ripple carry to high byte
0168   1077 D3 05               INC     R5          ; increment source
0169   1079 79 00 04            ADC     %$0,R4      ; ripple carry to high byte
0170   107C D2 02               DEC     R2          ; done yet?
0171   107E E6 EE               JNZ     CPYLOOP     ; if we are not done, loop to copy next byte
0172   1080                     ; our code copy to RAM is done
0173   1080 8C 00 08            BR      @RAMDEST    ; jump to code in RAM
0174   1083             
0175   1083             ; Start of code to be executed in RAM
0176   1083             ; (Must be relocatable)
0177   1083             
0178   1083             RAMCODE:
0179   1083 22 55               MOV     %$55,A      ; Byte signifying request to switch modes
0180   1085 8B 10 00            STA     @ARDADDR    ; switch modes
0181   1088 52 FF               MOV     %$FF,B      ; B = FF
0182   108A             DELAY:
0183   108A C2                  DEC     B           ; B = B-1
0184   108B E6 FD               JNZ     DELAY       ; wait a bit for things to settle
0185   108D 8C 10 90            BR      @BACK2ROM
0186   1090             
0187   1090             ;   Determine internal ROM size
0188   1090             
0189   1090             BACK2ROM:
0190   1090 72 08 02            MOV     %$08,R2     ; Number of 2K pages
0191   1093 88 C0 00 05         MOVD    %$C000,R5   ; Start of 16K ROM
0192   1097 9A 05       CHKNXT: LDA     *R5
0193   1099 32 04               MOV     R4,B        ; expected byte might have a bit 3 set, but we need to reset it
0194   109B 53 F7               AND     %$F7,B      ; before comparing to the byte read from ROM
0195   109D 6D                  CMP     B,A         ; expected byte in B if reading external memory
0196   109E E6 11               JNZ     FINISHUP
0197   10A0 D3 05               INC     R5
0198   10A2 7D 20 05            CMP     %$20,R5     ; done checking 32 bytes?
0199   10A5 E6 F0               JNZ     CHKNXT
0200   10A7 72 00 05            MOV     %$0,R5      ; if so, start next 2K region, + 0x0800
0201   10AA D2 02               DEC     R2          ; but first, subtract 1 from num of 2K regions
0202   10AC 78 08 04            ADD     %$8,R4
0203   10AF E6 E6               JNZ     CHKNXT      ; done with all regions?
0204   10B1             
0205   10B1             FINISHUP:
0206   10B1                     ; Update R3 with # of 2K pages from R2
0207   10B1 B0                  CLRC                ; put 2K page counter into bits 2,3,4,5
0208   10B2 DE 02               RL      R2
0209   10B4 DE 02               RL      R2
0210   10B6 48 02 03            ADD     R2,R3       ; add to ID byte in the right place
0211   10B9             
0212   10B9                     ; at this point:
0213   10B9                     ;   R3 is the complete ID byte
0214   10B9                     ;   R4 is the high byte of the start of internal rom to dump 
0215   10B9                     ;     (or 00)
0216   10B9 72 00 05            MOV     %$00,R5     ; now R4:R5 is the start of internal ROM (or 0000)
0217   10BC             
0218   10BC             SENDID:
0219   10BC 12 03               MOV     R3,A
0220   10BE 8B 10 00            STA     @ARDADDR    ; send ID byte to the arduino
0221   10C1             
0222   10C1 7D 00 04            CMP     %$00,R4     ; check if no internal rom
0223   10C4 E2 0C               JZ      DONE
0224   10C6             
0225   10C6             NXTBYTE:
0226   10C6 9A 05               LDA     *R5         ; Read internal ROM byte
0227   10C8 8B 10 00            STA     @ARDADDR    ; send a byte to the arduino
0228   10CB             
0229   10CB D3 05               INC     R5          ; increment for next location to read
0230   10CD 79 00 04            ADC     %$0,R4
0231   10D0 E6 F4               JNZ     NXTBYTE     ; unless we roll over to 0000, do next byte
0232   10D2             
0233   10D2             DONE:
0234   10D2 E0 FE               JMP     DONE        ; loop forever
0235   10D4             
0236   10D4             ; We fill the first 32 bytes of each of the last 4K regions with the high byte of the region
0237   10D4             ; (This shows up as the first 32 bytes in every 256 byte block of this region)
0238   10D4             ; We try to read them at the start of each 2K block, to determine if we are reading external or internal ROM
0239   10D4             ; In this way, we determine how much internal ROM there is
0240   10D4             
0241   C000                     .ORG    $C000       ; External Memory in the last 16K
0242   C000 C0 C0 C0 C0         .FILL   $20,$C0     ; If this data is read in Full Expansion mode at $C000, then this is not a 16K internal ROM chip
0242   C004 C0 C0 C0 C0 
0242   C008 C0 C0 C0 C0 
0242   C00C C0 C0 C0 C0 
0242   C010 C0 C0 C0 C0 
0242   C014 C0 C0 C0 C0 
0242   C018 C0 C0 C0 C0 
0242   C01C C0 C0 C0 C0 
0243   C020                                         ; If this data is read in Full Expansion mode at $C800, then this is not a 14K internal ROM chip
0244   C020             
0245   D000                     .ORG    $D000       ; External Memory in the last 12K
0246   D000 D0 D0 D0 D0         .FILL   $20,$D0     ; If this data is read in Full Expansion mode at $D000, then this is not a 12K internal ROM chip
0246   D004 D0 D0 D0 D0 
0246   D008 D0 D0 D0 D0 
0246   D00C D0 D0 D0 D0 
0246   D010 D0 D0 D0 D0 
0246   D014 D0 D0 D0 D0 
0246   D018 D0 D0 D0 D0 
0246   D01C D0 D0 D0 D0 
0247   D020                                         ; If this data is read in Full Expansion mode at $D800, then this is not a 10K internal ROM chip
0248   D020             
0249   E000                     .ORG    $E000       ; External Memory in the last 8K
0250   E000 E0 E0 E0 E0         .FILL   $20,$E0     ; If this data is read in Full Expansion mode at $E000, then this is not a 8K internal ROM chip
0250   E004 E0 E0 E0 E0 
0250   E008 E0 E0 E0 E0 
0250   E00C E0 E0 E0 E0 
0250   E010 E0 E0 E0 E0 
0250   E014 E0 E0 E0 E0 
0250   E018 E0 E0 E0 E0 
0250   E01C E0 E0 E0 E0 
0251   E020                                         ; If this data is read in Full Expansion mode at $E800, then this is not a 6K internal ROM chip
0252   E020             
0253   FF00                     .ORG    $FF00       ; External Memory in the last 4K
0254   FF00 F0 F0 F0 F0         .FILL   $20,$F0     ; If this data is read in Full Expansion mode at $F000, then this is not a 4K internal ROM chip
0254   FF04 F0 F0 F0 F0 
0254   FF08 F0 F0 F0 F0 
0254   FF0C F0 F0 F0 F0 
0254   FF10 F0 F0 F0 F0 
0254   FF14 F0 F0 F0 F0 
0254   FF18 F0 F0 F0 F0 
0254   FF1C F0 F0 F0 F0 
0255   FF20                                         ; If this data is read in Full Expansion mode at $F800, then this is not a 2K internal ROM chip
0256   FF20             
0257   FF20                     ; Vectors go here
0258   FF20             
0259   FFF4                     .ORG    $FFF4
0260   FFF4             
0261   FFF4                     .MSFIRST            ; need this, or .word statements are backwards for this CPU!
0262   FFF4             
0263   FFF4 10 00               .word   START       ;  INT5 vector
0264   FFF6 10 00               .word   START       ;  INT4 vector
0265   FFF8 10 00               .word   START       ; ~INT3 vector
0266   FFFA 10 00               .word   START       ;  INT2 vector
0267   FFFC 10 00               .word   START       ; ~INT1 vector
0268   FFFE 10 00               .word   START       ; ~RESET vector
0269   10000             
0270   10000                     .end
0271   10000             
0272   10000             
tasm: Number of errors = 0
