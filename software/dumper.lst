0001   0000             ;
0002   0000             ; Original Code and hardware by Frank Palazzolo
0003   0000             ; Code written and working sometime in the early 2000's
0004   0000             ; Source Reverse-engineered from Binary(!)
0005   0000             ; And updated for standard SPI master interface - 2022-October
0006   0000             ; Added Chip ID functions, 2022-November
0007   0000             ;
0008   0000             ; This code can be built with TASM Version 3.2:
0009   0000             ;   tasm -70 -g3 -fff -s -c dumper.asm dumper.bin
0010   0000             ;
0011   0000             ; Dumper code for:
0012   0000             ;       PIC7020, TMS7020 - 2K bytes ROM, 128 bytes RAM
0013   0000             ;       PIC7021, TMS7021 - 2K bytes ROM, 128 bytes RAM, peripherals
0014   0000             ;       PIC7040, TMS7040 - 4K bytes ROM, 128 bytes RAM
0015   0000             ;       PIC7041, TMS7041 - 4K bytes ROM, 128 bytes RAM, peripherals
0016   0000             ;       PIC7042, TMS7042 - 4K bytes ROM, 256 bytes RAM, peripherals
0017   0000             ;
0018   0000             ; Hardware connections:
0019   0000             ;
0020   0000             ; ~INT1 and ~INT3 wired to +5 - pins 13 and 12 on DIP
0021   0000             ; Port B, bit 0 - Pin 3 on DIP  - MC Pin is connected here, along with a 4.7k pullup 
0022   0000             ; Port B, bit 1 - Pin 4 on DIP  - MOSI - Bits appear here
0023   0000             ; Port B, bit 2 - Pin 5 on DIP  - SCLK - Rising Edge happens during bit
0024   0000             ; Port B, bit 3 - Pin 37 on DIP - ~SS
0025   0000             ;
0026   0000             ; When External Memory is enabled:
0027   0000             ;
0028   0000             ; Port B, bit 4 - Pin 38 on DIP - ALATCH
0029   0000             ; Port B, bit 5 - Pin 1 on DIP  - R/~W 
0030   0000             ; Port B, bit 6 - Pin 39 on DIP - ~ENABLE
0031   0000             ; Port B, bit 7 - Pin 2 on DIP  - CLKOUT 
0032   0000             ; Port C, all   - Address Low / Data Bus
0033   0000             ; Port D, all   - Address High Bus
0034   0000             
0035   0000             ; Chip starts up in Microprocessor mode, executing ROM from external memory
0036   0000             ; 1) Code checks ram size and for presence of serial port, to generate initial ID byte
0037   0000             ; 2) Trojan Code segment is copied from external ROM to internal RAM
0038   0000             ; 3) Jump to code in internal RAM 
0039   0000             ; 4) Switch modes, enabling internal ROM 
0040   0000             ; 5) Code determines internal ROM size and adjusts ID byte
0041   0000             ; 6) Code clocks out bytes via SPI:
0042   0000             ;    ID byte, followed by 0K, 2K, or 4K bytes
0043   0000             
0044   0000             ; RAM Layout
0045   0000             ; 0x00-0x07 - A,B,R2-R7 Used as general purpose storage
0046   0000             ; 0x08-0x7C - Used for Trojan program
0047   0000             ; 0x7D-0x7E - Spare
0048   0000             ; 0x7F      - used to determine RAM size
0049   0000             
0050   0000             ; ID Byte -
0051   0000             ;     0x00 - 0b00000000 - 128 bytes of ram, 0K ROM                - TMS/PIC7000
0052   0000             ;     0x01 - 0b00000001 - 128 bytes of ram, serial port, 0K ROM   - TMS/PIC7001
0053   0000             ;     0x02 - 0b00000010 - 256 bytes of ram, 0K ROM                - TMS/PIC700?
0054   0000             ;     0x03 - 0b00000011 - 256 bytes of ram, serial port, 0K ROM   - TMS/PIC7002
0055   0000             ;     0x04 - 0b00000100 - 128 bytes of ram, 2K ROM                - TMS/PIC7020
0056   0000             ;     0x05 - 0b00000101 - 128 bytes of ram, serial port, 2K ROM   - TMS/PIC7021
0057   0000             ;     0x06 - 0b00000110 - 256 bytes of ram, 0K ROM                - TMS/PIC702?
0058   0000             ;     0x07 - 0b00000111 - 256 bytes of ram, serial port, 2K ROM   - TMS/PIC7022
0059   0000             ;     0x08 - 0b00001000 - 128 bytes of ram, 4K ROM                - TMS/PIC7040
0060   0000             ;     0x09 - 0b00001001 - 128 bytes of ram, serial port, 4K ROM   - TMS/PIC7041
0061   0000             ;     0x0a - 0b00001010 - 256 bytes of ram, 4K ROM                - TMS/PIC704?
0062   0000             ;     0x0b - 0b00001011 - 256 bytes of ram, serial port, 12K ROM  - TMS/PIC7042
0063   0000             ;     0x10 - 0b00010000 - 128 bytes of ram, 12K ROM               - TMS/PIC70120
0064   0000             ;     0x11 - 0b00010001 - 128 bytes of ram, serial port, 12K ROM  - TMS/PIC70121
0065   0000             ;     0x12 - 0b00010010 - 256 bytes of ram, 12K ROM               - TMS/PIC7012?
0066   0000             ;     0x13 - 0b00010011 - 256 bytes of ram, serial port, 12K ROM  - TMS/PIC70122
0067   0000             ;     Any other values are errors
0068   0000             
0069   0000             ;R0      .equ    0   ; AKA A Register
0070   0000             ;R1      .equ    1   ; AKA B Register
0071   0000             R2      .equ    2
0072   0000             R3      .equ    3
0073   0000             R4      .equ    4
0074   0000             R5      .equ    5
0075   0000             R6      .equ    6
0076   0000             R7      .equ    7
0077   0000             
0078   0000             ; peripherals
0079   0000             
0080   0000             IOCNT0  .equ    0   ; Used to control modes via the CPU
0081   0000             BPORT   .equ    6   ; Used to switch modes via external connection, and used for SPI interface 
0082   0000             SCTL1   .equ    21  ; Used to probe for a Serial Port
0083   0000             
0084   0000             RAMDEST .equ    $0008       ; location in ram for the code to be copied into and run from
0085   0000                                         ; Right now, this just barely fits into 128 bytes of RAM
0086   0000             
0087   E000                     .ORG    $E000       ; External Memory in the last 8K
0088   E000 E0 E0 E0 E0         .FILL   $20,$E0     ; If this data is read in Full Expansion mode, then this is not a 12K internal ROM chip
0088   E004 E0 E0 E0 E0 
0088   E008 E0 E0 E0 E0 
0088   E00C E0 E0 E0 E0 
0088   E010 E0 E0 E0 E0 
0088   E014 E0 E0 E0 E0 
0088   E018 E0 E0 E0 E0 
0088   E01C E0 E0 E0 E0 
0089   E020             
0090   E800                     .ORG    $E800       ; External Memory in the last 6K
0091   E800 E8 E8 E8 E8         .FILL   $20,$E8     ; If this data is read in Full Expansion mode, then this is not a 12K internal ROM chip
0091   E804 E8 E8 E8 E8 
0091   E808 E8 E8 E8 E8 
0091   E80C E8 E8 E8 E8 
0091   E810 E8 E8 E8 E8 
0091   E814 E8 E8 E8 E8 
0091   E818 E8 E8 E8 E8 
0091   E81C E8 E8 E8 E8 
0092   E820             
0093   F000                     .ORG    $F000       ; External Memory in the last 4K
0094   F000 F0 F0 F0 F0         .FILL   $20,$F0     ; If this data is read in Full Expansion mode, then this is not a 4K internal ROM chip
0094   F004 F0 F0 F0 F0 
0094   F008 F0 F0 F0 F0 
0094   F00C F0 F0 F0 F0 
0094   F010 F0 F0 F0 F0 
0094   F014 F0 F0 F0 F0 
0094   F018 F0 F0 F0 F0 
0094   F01C F0 F0 F0 F0 
0095   F020             
0096   F800                     .ORG    $F800       ; External Memory in the last 2K
0097   F800 F8 F8 F8 F8         .FILL   $20,$F8     ; If this code is read in Full Expansion mode, then this is not a 2K internal ROM chip
0097   F804 F8 F8 F8 F8 
0097   F808 F8 F8 F8 F8 
0097   F80C F8 F8 F8 F8 
0097   F810 F8 F8 F8 F8 
0097   F814 F8 F8 F8 F8 
0097   F818 F8 F8 F8 F8 
0097   F81C F8 F8 F8 F8 
0098   F820             
0099   F820                     ; Initialize port, stack
0100   F820             START:
0101   F820 A2 FF 06            MOVP    %$FF,BPORT  ; PORTB = FF, PORTB=All ones (MC high, make sure external ROM enabled)
0102   F823 52 0C               MOV     %$0C,B      ; B  = 0C
0103   F825 0D                  LDSP                ; SP = 000C - we don't use stack anyway
0104   F826 A2 AA 00            MOVP    %$AA,IOCNT0 ; Disable some interrupts, set for Full Expansion mode after mode switch
0105   F829             
0106   F829                     ; Try to identify this chip and store a code in R3
0107   F829             
0108   F829             RAMCHK:
0109   F829                     ; Identify RAM size:
0110   F829                     ; do checks twice with different data,
0111   F829                     ; to protect against random luck matches
0112   F829             
0113   F829 72 55 FF            MOV     %$55,$ff
0114   F82C 72 AA 7F            MOV     %$AA,$7f
0115   F82F 7D 55 FF            CMP     %$55,$ff    ; check for 256 bytes working
0116   F832 E6 10               JNZ     RAM128
0117   F834 72 AA FF            MOV     %$AA,$ff
0118   F837 72 55 7F            MOV     %$55,$7f
0119   F83A 7D AA FF            CMP     %$AA,$ff    ; doublecheck for 256 bytes working
0120   F83D E6 05               JNZ     RAM128
0121   F83F             
0122   F83F             RAM256:
0123   F83F 72 02 03            MOV     %$02,R3     ; 256 bytes
0124   F842 E0 05               JMP     SERCHK
0125   F844             RAM128:
0126   F844 72 00 03            MOV     %$00,R3     ; 128 bytes
0127   F847 E0 00               JMP     SERCHK
0128   F849             
0129   F849                     ; Try to store bottom two bits of SCTL1 register and see if they stay
0130   F849                     ; if so, we have a UART
0131   F849             SERCHK:
0132   F849 A3 FC 15            ANDP    %$FC,SCTL1  ; zero the 2 LS bits
0133   F84C 80 15               MOVP    SCTL1,A
0134   F84E 23 03               AND     %$03,A
0135   F850 E6 19               JNZ     SERFAIL     ; fail if not zero
0136   F852 A4 01 15            ORP     %$01,SCTL1  ; set the bottom bit
0137   F855 80 15               MOVP    SCTL1,A
0138   F857 23 03               AND     %$03,A 
0139   F859 2D 01               CMP     %$01,A      ; check if it's a one now
0140   F85B E6 0E               JNZ     SERFAIL     ; or fail
0141   F85D A4 02 15            ORP     %$02,SCTL1  ; set the next bit
0142   F860 80 15               MOVP    SCTL1,A
0143   F862 23 03               AND     %$03,A 
0144   F864 2D 03               CMP     %$03,A      ; should be 3 now
0145   F866 E6 03               JNZ     SERFAIL     ; if not fail
0146   F868             SERFOUND:
0147   F868 74 01 03            OR      %$01,R3     ; UART detected, set this bit
0148   F86B             SERFAIL:
0149   F86B             
0150   F86B                     ; Copy code from External ROM to RAM
0151   F86B             
0152   F86B             COPYCODE:
0153   F86B 88 F8 8E 05         MOVD    %RAMCODE,R5 ; Start of ROM source
0154   F86F 88 00 08 07         MOVD    %RAMDEST,R7 ; Start of RAM destination
0155   F873             CPYLOOP:
0156   F873 9A 05               LDA     *R5         ; grab code byte
0157   F875 9B 07               STA     *R7         ; move code byte
0158   F877 D3 07               INC     R7          ; increment destination
0159   F879 79 00 06            ADC     %$0,R6      ; ripple carry to high byte
0160   F87C D3 05               INC     R5          ; increment source
0161   F87E 79 00 04            ADC     %$0,R4      ; ripple carry to high byte
0162   F881 7D F9 04            CMP     %(ENDCODE/$100),R4          ; am I at high byte of ENDCODE?
0163   F884 E6 ED               JNZ     CPYLOOP     ; if we are not done, loop to copy next byte
0164   F886 7D 03 05            CMP     %$(ENDCODE%$100),R5         ; am I at low byte of ENDCODE?
0165   F889 E6 E8               JNZ     CPYLOOP     ; if we are not done, loop to copy next byte
0166   F88B             
0167   F88B                     ; We reached ENDCODE, so our code copy to RAM is done
0168   F88B 8C 00 08            BR      @RAMDEST    ; jump to code in RAM
0169   F88E             
0170   F88E             ; Start of code to be executed in RAM
0171   F88E             ; (Must be relocatable)
0172   F88E             
0173   F88E             RAMCODE:
0174   F88E A2 FE 06            MOVP    %$FE,BPORT  ; PORTB = FE, PORTB.0=0 (Flip the MC pin low, internal ROM enabled)
0175   F891 52 FF               MOV     %$FF,B      ; B = FF
0176   F893             DELAY:
0177   F893 C2                  DEC     B           ; B = B-1
0178   F894 E6 FD               JNZ     DELAY       ; wait a bit for things to settle
0179   F896             
0180   F896             ;   determine internal ROM size
0181   F896             
0182   F896 88 E8 00 05         MOVD    %$E800,R5   ; Start of 6K ROM
0183   F89A 9A 05       X1:     LDA     *R5
0184   F89C 1D 04               CMP     R4,A        ; expected byte in R4 if reading external memory
0185   F89E E6 11               JNZ     NOMATCH
0186   F8A0 D3 05               INC     R5
0187   F8A2 7D 20 05            CMP     %$20,R5     ; done checking 32 bytes?
0188   F8A5 E6 F3               JNZ     X1
0189   F8A7 72 00 05            MOV     %$0,R5      ; if so, start next region, + 0x0800
0190   F8AA 78 08 04            ADD     %$8,R4
0191   F8AD E6 EB               JNZ     X1          ; done with all regions?
0192   F8AF             
0193   F8AF             ROM0K:
0194   F8AF E0 1A               JMP     FINISHUP
0195   F8B1             
0196   F8B1             NOMATCH:
0197   F8B1 7D E8 04            CMP     %$E8,R4     ; 12K ROM check if match
0198   F8B4 E6 08               JNZ     NEXTCHK
0199   F8B6             
0200   F8B6             ROM12K:
0201   F8B6 74 10 03            OR      %$10,R3
0202   F8B9 72 CF 04            MOV     %$CF,R4     ; R4:R5 = D000-1, (Start of 12K Internal ROM)
0203   F8BC E0 0F               JMP     DODUMP
0204   F8BE             
0205   F8BE             NEXTCHK:
0206   F8BE 7D F0 04            CMP     %$F0,R4     ; 4K ROM if match
0207   F8C1 E6 05               JNZ     ROM2K
0208   F8C3             
0209   F8C3 74 08 03    ROM4K:  OR      %$08,R3
0210   F8C6 E0 03               JMP     FINISHUP
0211   F8C8                                         
0212   F8C8             ROM2K:  
0213   F8C8 74 04 03            OR      %$04,R3
0214   F8CB             FINISHUP:
0215   F8CB D2 04               DEC     R4          ;    R4:R5 = 0000-1, (End of Internal ROM)
0216   F8CD                                         ; or R4:R5 = F000-1, (Start of 4K Internal ROM)
0217   F8CD                                         ; or R4:R5 = F800-1, (Start of 2K Internal ROM)
0218   F8CD                     
0219   F8CD             DODUMP:
0220   F8CD 72 FF 05            MOV     %$FF,R5
0221   F8D0             
0222   F8D0 A3 FB 06            ANDP    %$FB,BPORT  ; PORTB.2 = SCK = 0
0223   F8D3 A3 F7 06            ANDP    %$F7,BPORT  ; PORTB.3 = ~SS = 0
0224   F8D6 12 03               MOV     R3,A
0225   F8D8 E0 02               JMP     JUMPIN
0226   F8DA             
0227   F8DA             NXTBYTE:
0228   F8DA 9A 05               LDA     *R5         ; Read internal ROM byte
0229   F8DC             JUMPIN:
0230   F8DC 72 08 02            MOV     %$8,R2      ; R2 = 8, bit counter?
0231   F8DF             NXTBIT:
0232   F8DF A3 FB 06            ANDP    %$FB,BPORT  ; PORTB.2 = SCK = 0
0233   F8E2             
0234   F8E2 BE                  RL      A           ; get each bit, MSB first
0235   F8E3 E3 05               JHS     DOONE       ; if 1, jump
0236   F8E5 A3 FD 06            ANDP    %$FD,BPORT  ; PORTB.1 = MOSI = 0
0237   F8E8 E0 03               JMP     AHEAD
0238   F8EA             DOONE:
0239   F8EA A4 02 06            ORP     %$02,BPORT  ; PORTB.1 = MOSI = 1
0240   F8ED             AHEAD:
0241   F8ED A4 04 06            ORP     %$04,BPORT  ; PORTB.2 = SCK = 1
0242   F8F0 D2 02               DEC     R2          ; decrement bit counter
0243   F8F2 E6 EB               JNZ     NXTBIT      ; do next bit
0244   F8F4             
0245   F8F4 D3 05               INC     R5          ; increment for next location to read
0246   F8F6 79 00 04            ADC     %$0,R4
0247   F8F9 E6 DF               JNZ     NXTBYTE     ; unless we roll over to 0000, do next byte
0248   F8FB             
0249   F8FB A3 FB 06            ANDP    %$FB,BPORT  ; PORTB.2 = SCK = 0
0250   F8FE A4 08 06            ORP     %$08,BPORT  ; PORTB.3 = ~SS = 1
0251   F901             
0252   F901             DONE:
0253   F901 E0 FE               JMP     DONE        ; loop forever
0254   F903             ENDCODE:
0255   F903             ;       End of code to be executed in RAM
0256   F903             
0257   F903             RPRGSIZE .equ   ENDCODE-RAMCODE
0258   F903             
0259   F903                     ; Vectors go here
0260   F903             
0261   FFF8                     .ORG    0FFF8H
0262   FFF8             
0263   FFF8                     .MSFIRST            ; need this, or .word statements are backwards for this CPU
0264   FFF8             
0265   FFF8 F8 20               .word   START
0266   FFFA F8 20               .word   START
0267   FFFC F8 20               .word   START
0268   FFFE F8 20               .word   START
0269   10000             
0270   10000                     .end
0271   10000             
0272   10000             
tasm: Number of errors = 0
